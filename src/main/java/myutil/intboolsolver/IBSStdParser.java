
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20210814 (GIT d69c832)
//----------------------------------------------------

package myutil.intboolsolver;

import java_cup.runtime.*;
import java.util.HashSet;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20210814 (GIT d69c832) generated parser.
  */
@SuppressWarnings("unused")
public class IBSStdParser< Spec extends IBSParamSpec, Comp extends IBSParamComp, State extends IBSParamState, SpecState extends IBSParamSpecState, CompState extends IBSParamCompState > extends java_cup.runtime.lr_parser {

 @Override
 public final Class<?> getSymbolContainer() {
    return IBSStdParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public IBSStdParser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public IBSStdParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public IBSStdParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\035\000\002\002\004\000\002\002\004\000\002\002" +
    "\004\000\002\003\005\000\002\003\005\000\002\003\003" +
    "\000\002\004\005\000\002\004\005\000\002\004\005\000" +
    "\002\004\003\000\002\005\003\000\002\005\005\000\002" +
    "\005\004\000\002\006\005\000\002\006\003\000\002\007" +
    "\005\000\002\007\003\000\002\010\003\000\002\010\003" +
    "\000\002\010\005\000\002\010\004\000\002\011\005\000" +
    "\002\011\005\000\002\011\005\000\002\011\005\000\002" +
    "\011\005\000\002\011\005\000\002\011\005\000\002\011" +
    "\005" });

  /** Access to production table. */
  @Override
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\071\000\006\024\004\025\005\001\002\000\010\005" +
    "\010\022\027\026\012\001\002\000\014\005\010\021\021" +
    "\022\015\026\012\027\013\001\002\000\004\002\007\001" +
    "\002\000\004\002\000\001\002\000\010\005\010\022\027" +
    "\026\012\001\002\000\016\002\ufff1\011\ufff1\012\ufff1\013" +
    "\ufff1\014\ufff1\023\ufff1\001\002\000\040\002\ufff7\004\ufff7" +
    "\005\ufff7\006\ufff7\007\ufff7\010\ufff7\011\ufff7\012\ufff7\013" +
    "\ufff7\014\ufff7\015\ufff7\016\ufff7\017\ufff7\020\ufff7\023\ufff7" +
    "\001\002\000\016\002\ufff0\011\ufff0\012\ufff0\013\ufff0\014" +
    "\ufff0\023\ufff0\001\002\000\012\002\001\012\044\013\043" +
    "\014\042\001\002\000\014\005\010\021\021\022\015\026" +
    "\012\027\013\001\002\000\040\002\ufff8\004\ufff8\005\ufff8" +
    "\006\ufff8\007\ufff8\010\ufff8\011\ufff8\012\ufff8\013\ufff8\014" +
    "\ufff8\015\ufff8\016\ufff8\017\ufff8\020\ufff8\023\ufff8\001\002" +
    "\000\016\002\ufff3\011\047\012\ufff3\013\ufff3\014\ufff3\023" +
    "\ufff3\001\002\000\022\004\032\005\033\013\053\014\054" +
    "\015\055\016\056\017\060\020\057\001\002\000\014\005" +
    "\010\021\021\022\015\026\012\027\013\001\002\000\040" +
    "\002\ufffc\004\ufffc\005\ufffc\006\025\007\026\010\024\011" +
    "\ufffc\012\ufffc\013\ufffc\014\ufffc\015\ufffc\016\ufffc\017\ufffc" +
    "\020\ufffc\023\ufffc\001\002\000\016\002\uffef\011\uffef\012" +
    "\uffef\013\uffef\014\uffef\023\uffef\001\002\000\010\005\010" +
    "\022\027\026\012\001\002\000\010\005\010\022\027\026" +
    "\012\001\002\000\010\005\010\022\027\026\012\001\002" +
    "\000\010\005\010\022\027\026\012\001\002\000\040\002" +
    "\ufffa\004\ufffa\005\ufffa\006\ufffa\007\ufffa\010\ufffa\011\ufffa" +
    "\012\ufffa\013\ufffa\014\ufffa\015\ufffa\016\ufffa\017\ufffa\020" +
    "\ufffa\023\ufffa\001\002\000\010\004\032\005\033\023\034" +
    "\001\002\000\010\005\010\022\027\026\012\001\002\000" +
    "\010\005\010\022\027\026\012\001\002\000\040\002\ufff6" +
    "\004\ufff6\005\ufff6\006\ufff6\007\ufff6\010\ufff6\011\ufff6\012" +
    "\ufff6\013\ufff6\014\ufff6\015\ufff6\016\ufff6\017\ufff6\020\ufff6" +
    "\023\ufff6\001\002\000\040\002\ufffd\004\ufffd\005\ufffd\006" +
    "\025\007\026\010\024\011\ufffd\012\ufffd\013\ufffd\014\ufffd" +
    "\015\ufffd\016\ufffd\017\ufffd\020\ufffd\023\ufffd\001\002\000" +
    "\040\002\ufffe\004\ufffe\005\ufffe\006\025\007\026\010\024" +
    "\011\ufffe\012\ufffe\013\ufffe\014\ufffe\015\ufffe\016\ufffe\017" +
    "\ufffe\020\ufffe\023\ufffe\001\002\000\040\002\ufffb\004\ufffb" +
    "\005\ufffb\006\ufffb\007\ufffb\010\ufffb\011\ufffb\012\ufffb\013" +
    "\ufffb\014\ufffb\015\ufffb\016\ufffb\017\ufffb\020\ufffb\023\ufffb" +
    "\001\002\000\040\002\ufff9\004\ufff9\005\ufff9\006\ufff9\007" +
    "\ufff9\010\ufff9\011\ufff9\012\ufff9\013\ufff9\014\ufff9\015\ufff9" +
    "\016\ufff9\017\ufff9\020\ufff9\023\ufff9\001\002\000\016\002" +
    "\uffed\011\uffed\012\uffed\013\043\014\042\023\uffed\001\002" +
    "\000\014\005\010\021\021\022\015\026\012\027\013\001" +
    "\002\000\014\005\010\021\021\022\015\026\012\027\013" +
    "\001\002\000\014\005\010\021\021\022\015\026\012\027" +
    "\013\001\002\000\010\012\044\013\043\014\042\001\002" +
    "\000\016\002\ufff4\011\047\012\ufff4\013\ufff4\014\ufff4\023" +
    "\ufff4\001\002\000\014\005\010\021\021\022\015\026\012" +
    "\027\013\001\002\000\016\002\ufff2\011\ufff2\012\ufff2\013" +
    "\ufff2\014\ufff2\023\ufff2\001\002\000\016\002\uffe6\011\uffe6" +
    "\012\uffe6\013\uffe6\014\uffe6\023\uffe6\001\002\000\016\002" +
    "\uffe5\011\uffe5\012\uffe5\013\uffe5\014\uffe5\023\uffe5\001\002" +
    "\000\010\005\010\022\027\026\012\001\002\000\010\005" +
    "\010\022\027\026\012\001\002\000\010\005\010\022\027" +
    "\026\012\001\002\000\010\005\010\022\027\026\012\001" +
    "\002\000\010\005\010\022\027\026\012\001\002\000\010" +
    "\005\010\022\027\026\012\001\002\000\022\002\uffea\004" +
    "\032\005\033\011\uffea\012\uffea\013\uffea\014\uffea\023\uffea" +
    "\001\002\000\022\002\uffe9\004\032\005\033\011\uffe9\012" +
    "\uffe9\013\uffe9\014\uffe9\023\uffe9\001\002\000\022\002\uffeb" +
    "\004\032\005\033\011\uffeb\012\uffeb\013\uffeb\014\uffeb\023" +
    "\uffeb\001\002\000\022\002\uffec\004\032\005\033\011\uffec" +
    "\012\uffec\013\uffec\014\uffec\023\uffec\001\002\000\022\002" +
    "\uffe7\004\032\005\033\011\uffe7\012\uffe7\013\uffe7\014\uffe7" +
    "\023\uffe7\001\002\000\022\002\uffe8\004\032\005\033\011" +
    "\uffe8\012\uffe8\013\uffe8\014\uffe8\023\uffe8\001\002\000\012" +
    "\012\044\013\043\014\042\023\071\001\002\000\024\004" +
    "\032\005\033\013\053\014\054\015\055\016\056\017\060" +
    "\020\057\023\034\001\002\000\016\002\uffee\011\uffee\012" +
    "\uffee\013\uffee\014\uffee\023\uffee\001\002\000\040\002\ufff5" +
    "\004\ufff5\005\ufff5\006\ufff5\007\ufff5\010\ufff5\011\ufff5\012" +
    "\ufff5\013\ufff5\014\ufff5\015\ufff5\016\ufff5\017\ufff5\020\ufff5" +
    "\023\ufff5\001\002\000\010\002\uffff\004\032\005\033\001" +
    "\002" });

  /** Access to parse-action table. */
  @Override
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\071\000\004\002\005\001\001\000\010\003\072\004" +
    "\021\005\015\001\001\000\020\003\017\004\021\005\015" +
    "\006\013\007\016\010\010\011\022\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\005\071\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\020\003\067\004\021\005\015\006\066\007\016" +
    "\010\010\011\022\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\020\003\017\004\021\005\015" +
    "\006\040\007\016\010\010\011\022\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\005\037\001\001\000\004" +
    "\005\036\001\001\000\004\005\027\001\001\000\010\003" +
    "\030\004\021\005\015\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\004\035\005\015\001\001\000\006\004" +
    "\034\005\015\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\020\003\017\004\021\005\015\006\051" +
    "\007\016\010\010\011\022\001\001\000\020\003\017\004" +
    "\021\005\015\006\050\007\016\010\010\011\022\001\001" +
    "\000\020\003\017\004\021\005\015\006\044\007\045\010" +
    "\010\011\022\001\001\000\002\001\001\000\002\001\001" +
    "\000\020\003\017\004\021\005\015\006\044\007\016\010" +
    "\047\011\022\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\003\065\004\021\005\015\001" +
    "\001\000\010\003\064\004\021\005\015\001\001\000\010" +
    "\003\063\004\021\005\015\001\001\000\010\003\062\004" +
    "\021\005\015\001\001\000\010\003\061\004\021\005\015" +
    "\001\001\000\010\003\060\004\021\005\015\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  @Override
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$IBSStdParser$actions action_obj;

  /** Action encapsulation object initializer. */
  @Override
  protected void init_actions()
    {
      action_obj = new CUP$IBSStdParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  @Override
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack<java_cup.runtime.Symbol>    stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$IBSStdParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  @Override
  public int start_state() {return 0;}
  /** Indicates start production. */
  @Override
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  @Override
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  @Override
  public int error_sym() {return 1;}




    IBSStdLexer<Spec,Comp,State,SpecState,CompState> lexer;
    
    public void setLexer(IBSStdLexer<Spec,Comp,State,SpecState,CompState> _lexer){ lexer=_lexer; setScanner(_lexer); }

    public void setAttributeClass(IBSAttributeClass<Spec,Comp,State,SpecState,CompState> _c){ lexer.setAttributeClass(_c); }

    public IBSAttributeClass<Spec,Comp,State,SpecState,CompState> getAttributeClass(){ return lexer.getAttributeClass(); }

    public void setExpressionClass(IBSExpressionClass<Spec,Comp,State,SpecState,CompState> _c){ lexer.setExpressionClass(_c); }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState> getExpressionClass(){ return lexer.getExpressionClass(); }

    public HashSet<String> getBadIdents(){ return lexer.getBadIdents(); }

    public void clearBadIdents(){ lexer.clearBadIdents(); }

    public boolean syntaxError(){ return false; }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr parseInt(Spec _spec, String _s){
        try { lexer.init(_spec,"integer " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr parseBool(Spec _spec, String _s){
        try { lexer.init(_spec,"boolean " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr parseInt(Comp _comp, String _s){
        try { lexer.init(_comp,"integer " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr parseBool(Comp _comp, String _s){
        try { lexer.init(_comp,"boolean " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr parseInt(String _s){
        try { lexer.init("integer " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr parseBool(String _s){
        try { lexer.init("boolean " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr
    makeInt(IBSAttributeClass<Spec,Comp,State,SpecState,CompState>.Attribute _attr){
        int index = lexer.getExpressionClass().make_iVar(_attr);
        if (index >= 0) {
            IBSExpressionClass<Spec, Comp, State, SpecState, CompState>.IExpr res = lexer.getExpressionClass().getIExpr(index);
            lexer.getExpressionClass().freeInt(index);
            return res;
        }
        // if (index==-1) syntaxError=true; else syntaxError=false;
        return null;
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr
    makeBool(IBSAttributeClass<Spec,Comp,State,SpecState,CompState>.Attribute _attr){
        int index = lexer.getExpressionClass().make_bVar(_attr);
        if (index >= 0) {
            IBSExpressionClass<Spec, Comp, State, SpecState, CompState>.BExpr res = lexer.getExpressionClass().getBExpr(index);
            lexer.getExpressionClass().freeBool(index);
            return res;
        }
        // if (index==-1) syntaxError=true; else syntaxError=false;
        return null;
    }

    // A DEPLACER ...

    public int indexOfVariable(String expr, String variable) {
        int index;
        String tmp = expr;
        int removed = 0;
        //System.out.println("\nHandling expr: " + expr);

        while ((index = tmp.indexOf(variable)) > -1) {
            char c1, c2;
            if (index > 0) {
                c1 = tmp.charAt(index - 1);
            } else {
                c1 = ' ';
            }

            if (index + variable.length() < tmp.length())
                c2 = tmp.charAt(index + variable.length());
            else
                c2 = ' ';

            //System.out.println("tmp=" + tmp + " c1=" + c1 + " c2=" + c2);

            if (!(Character.isLetterOrDigit(c1) || (c1 == '_'))) {
                if (!(Character.isLetterOrDigit(c2) || (c2 == '_'))) {
                    //System.out.println("Found at index=" + index + " returnedIndex=" + (index+removed));
                    return index + removed;
                }
            }
            tmp = tmp.substring(index + variable.length(), tmp.length());
            //System.out.println("tmp=" + tmp);
            removed = index + variable.length();
            if (tmp.length() == 0) {
                return -1;
            }
            // We cut until we find a non alphanumerical character
            while (Character.isLetterOrDigit(tmp.charAt(0)) || (tmp.charAt(0) == '_')) {
                tmp = tmp.substring(1, tmp.length());
                if (tmp.length() == 0) {
                    return -1;
                }
                removed++;
            }
            //System.out.println("after remove: tmp=" + tmp);

        }
        return -1;
    }


    public String replaceVariable(String expr, String oldVariable, String newVariable) {
        if (oldVariable.compareTo(newVariable) == 0) {
            return expr;
        }
        int index;
        String tmp = expr;

        while ((index = indexOfVariable(tmp, oldVariable)) > -1) {
            String tmp1 = "";
            if (index > 0) {
                tmp1 = tmp.substring(0, index);
            }
            tmp1 += newVariable;
            tmp1 += tmp.substring(index + oldVariable.length(), tmp.length());
            tmp = tmp1;
        }

        return tmp;
    }



/** Cup generated class to encapsulate user supplied action code.*/
class CUP$IBSStdParser$actions {
  private final IBSStdParser parser;

  /** Constructor */
  CUP$IBSStdParser$actions(IBSStdParser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$IBSStdParser$do_action_part00000000(
    int                        CUP$IBSStdParser$act_num,
    java_cup.runtime.lr_parser CUP$IBSStdParser$parser,
    java.util.Stack<java_cup.runtime.Symbol>    CUP$IBSStdParser$stack,
    int                        CUP$IBSStdParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$IBSStdParser$result;

      /* select the action based on the action number */
      switch (CUP$IBSStdParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // expr ::= PARSE_BOOL bexpr 
            {
              IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.Expr RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = lexer.getExpressionClass().getBExpr(e.intValue());
                            lexer.getExpressionClass().freeBool(e.intValue()); 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("expr",0, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= expr EOF 
            {
              Object RESULT =null;
		int start_valleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1)).left;
		int start_valright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1)).right;
		IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.Expr start_val = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1).<IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.Expr>value();
		RESULT = start_val;
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("$START",0, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          /* ACCEPT */
          CUP$IBSStdParser$parser.done_parsing();
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // expr ::= PARSE_INT iexpr 
            {
              IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.Expr RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = lexer.getExpressionClass().getIExpr(e.intValue());
                            lexer.getExpressionClass().freeBool(e.intValue()); 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("expr",0, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // iexpr ::= iexpr PLUS ifact 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiPlus(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("iexpr",1, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // iexpr ::= iexpr MINUS ifact 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiMinus(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("iexpr",1, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // iexpr ::= ifact 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("iexpr",1, CUP$IBSStdParser$stack.peek(), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // ifact ::= ifact MULT iatom 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiMult(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("ifact",2, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // ifact ::= ifact DIV iatom 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiDiv(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("ifact",2, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // ifact ::= ifact MOD iatom 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiMod(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("ifact",2, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ifact ::= iatom 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("ifact",2, CUP$IBSStdParser$stack.peek(), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // iatom ::= INT 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("iatom",3, CUP$IBSStdParser$stack.peek(), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // iatom ::= LPAR iexpr RPAR 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1)).left;
		int eright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1)).right;
		Integer e = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1).<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("iatom",3, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // iatom ::= MINUS iatom 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_iNeg(e.intValue())); 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("iatom",3, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // bexpr ::= bexpr OR bfact 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbOr(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bexpr",4, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // bexpr ::= bfact 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bexpr",4, CUP$IBSStdParser$stack.peek(), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // bfact ::= bfact AND batom 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbAnd(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bfact",5, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // bfact ::= batom 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bfact",5, CUP$IBSStdParser$stack.peek(), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // batom ::= BOOL 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("batom",6, CUP$IBSStdParser$stack.peek(), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // batom ::= bcomp 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("batom",6, CUP$IBSStdParser$stack.peek(), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // batom ::= LPAR bexpr RPAR 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1)).left;
		int eright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1)).right;
		Integer e = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1).<Integer>value();
		 RESULT = e; 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("batom",6, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // batom ::= NOT bexpr 
            {
              Integer RESULT =null;
		int eleft = (CUP$IBSStdParser$stack.peek()).left;
		int eright = (CUP$IBSStdParser$stack.peek()).right;
		Integer e = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_bNot(e.intValue())); 
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("batom",6, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-1), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // bcomp ::= iexpr LT iexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiLt(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // bcomp ::= iexpr GT iexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiGt(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // bcomp ::= iexpr LEQ iexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiLeq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // bcomp ::= iexpr GEQ iexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiGeq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // bcomp ::= iexpr EQ iexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiEq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // bcomp ::= iexpr DIF iexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiDif(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // bcomp ::= bexpr EQ bexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbEq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // bcomp ::= bexpr DIF bexpr 
            {
              Integer RESULT =null;
		int lleft = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).left;
		int lright = (CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2)).right;
		Integer l = CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2).<Integer>value();
		int rleft = (CUP$IBSStdParser$stack.peek()).left;
		int rright = (CUP$IBSStdParser$stack.peek()).right;
		Integer r = CUP$IBSStdParser$stack.peek().<Integer>value();
		 RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbDif(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      
              CUP$IBSStdParser$result = parser.getSymbolFactory().newSymbol("bcomp",7, CUP$IBSStdParser$stack.elementAt(CUP$IBSStdParser$top-2), CUP$IBSStdParser$stack.peek(), RESULT);
            }
          return CUP$IBSStdParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$IBSStdParser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$IBSStdParser$do_action(
    int                        CUP$IBSStdParser$act_num,
    java_cup.runtime.lr_parser CUP$IBSStdParser$parser,
    java.util.Stack<java_cup.runtime.Symbol>     CUP$IBSStdParser$stack,
    int                        CUP$IBSStdParser$top)
    throws java.lang.Exception
    {
              return CUP$IBSStdParser$do_action_part00000000(
                               CUP$IBSStdParser$act_num,
                               CUP$IBSStdParser$parser,
                               CUP$IBSStdParser$stack,
                               CUP$IBSStdParser$top);
    }
}

}
