
package myutil.intboolsolver;
import java_cup.runtime.*;
import java.util.HashSet;


/* class IBSStdParser; */
/* To add in generated file:
   < Spec extends IBSParamSpec, Comp extends IBSParamComp, State extends IBSParamState, SpecState extends IBSParamSpecState, CompState extends IBSParamCompState >
*/

parser code {:

    IBSScanner<Spec,Comp,State,SpecState,CompState> lexer;
    
    public void setLexer(IBSScanner<Spec,Comp,State,SpecState,CompState> _lexer){ lexer=_lexer; setScanner(_lexer); }

    public void setAttributeClass(IBSAttributeClass<Spec,Comp,State,SpecState,CompState> _c){ lexer.setAttributeClass(_c); }

    public IBSAttributeClass<Spec,Comp,State,SpecState,CompState> getAttributeClass(){ return lexer.getAttributeClass(); }

    public void setExpressionClass(IBSExpressionClass<Spec,Comp,State,SpecState,CompState> _c){ lexer.setExpressionClass(_c); }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState> getExpressionClass(){ return lexer.getExpressionClass(); }

    public HashSet<String> getBadIdents(){ return lexer.getBadIdents(); }

    public void clearBadIdents(){ lexer.clearBadIdents(); }

    public boolean syntaxError(){ return false; }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr parseInt(Spec _spec, String _s){
        try { lexer.init(_spec,"integer " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr parseBool(Spec _spec, String _s){
        try { lexer.init(_spec,"boolean " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr parseInt(Comp _comp, String _s){
        try { lexer.init(_comp,"integer " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr parseBool(Comp _comp, String _s){
        try { lexer.init(_comp,"boolean " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr parseInt(String _s){
        try { lexer.init("integer " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr parseBool(String _s){
        try { lexer.init("boolean " + _s); }
        catch (java.io.IOException e) { return null; }
        try { return (IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr) parse().value; }
        catch (Exception e) { lexer.getExpressionClass().clear(); return null; }
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.IExpr
    makeInt(IBSAttributeClass<Spec,Comp,State,SpecState,CompState>.Attribute _attr){
        int index = lexer.getExpressionClass().make_iVar(_attr);
        if (index >= 0) {
            IBSExpressionClass<Spec, Comp, State, SpecState, CompState>.IExpr res = lexer.getExpressionClass().getIExpr(index);
            lexer.getExpressionClass().freeInt(index);
            return res;
        }
        // if (index==-1) syntaxError=true; else syntaxError=false;
        return null;
    }

    public IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.BExpr
    makeBool(IBSAttributeClass<Spec,Comp,State,SpecState,CompState>.Attribute _attr){
        int index = lexer.getExpressionClass().make_bVar(_attr);
        if (index >= 0) {
            IBSExpressionClass<Spec, Comp, State, SpecState, CompState>.BExpr res = lexer.getExpressionClass().getBExpr(index);
            lexer.getExpressionClass().freeBool(index);
            return res;
        }
        // if (index==-1) syntaxError=true; else syntaxError=false;
        return null;
    }

    // A DEPLACER ...

    public int indexOfVariable(String expr, String variable) {
        int index;
        String tmp = expr;
        int removed = 0;
        //System.out.println("\nHandling expr: " + expr);

        while ((index = tmp.indexOf(variable)) > -1) {
            char c1, c2;
            if (index > 0) {
                c1 = tmp.charAt(index - 1);
            } else {
                c1 = ' ';
            }

            if (index + variable.length() < tmp.length())
                c2 = tmp.charAt(index + variable.length());
            else
                c2 = ' ';

            //System.out.println("tmp=" + tmp + " c1=" + c1 + " c2=" + c2);

            if (!(Character.isLetterOrDigit(c1) || (c1 == '_'))) {
                if (!(Character.isLetterOrDigit(c2) || (c2 == '_'))) {
                    //System.out.println("Found at index=" + index + " returnedIndex=" + (index+removed));
                    return index + removed;
                }
            }
            tmp = tmp.substring(index + variable.length(), tmp.length());
            //System.out.println("tmp=" + tmp);
            removed = index + variable.length();
            if (tmp.length() == 0) {
                return -1;
            }
            // We cut until we find a non alphanumerical character
            while (Character.isLetterOrDigit(tmp.charAt(0)) || (tmp.charAt(0) == '_')) {
                tmp = tmp.substring(1, tmp.length());
                if (tmp.length() == 0) {
                    return -1;
                }
                removed++;
            }
            //System.out.println("after remove: tmp=" + tmp);

        }
        return -1;
    }


    public String replaceVariable(String expr, String oldVariable, String newVariable) {
        if (oldVariable.compareTo(newVariable) == 0) {
            return expr;
        }
        int index;
        String tmp = expr;

        while ((index = indexOfVariable(tmp, oldVariable)) > -1) {
            String tmp1 = "";
            if (index > 0) {
                tmp1 = tmp.substring(0, index);
            }
            tmp1 += newVariable;
            tmp1 += tmp.substring(index + oldVariable.length(), tmp.length());
            tmp = tmp1;
        }

        return tmp;
    }

:}


/* Terminals (tokens returned by the scanner). */
terminal            PLUS, MINUS, MULT, DIV, MOD, AND, OR, EQ, DIF, LT, GT, LEQ, GEQ;
terminal            NOT, LPAR, RPAR, UMINUS;
terminal            PARSE_INT, PARSE_BOOL;
terminal Integer    INT, BOOL;


/* Non terminals */
non terminal IBSExpressionClass<Spec,Comp,State,SpecState,CompState>.Expr expr;
non terminal Integer    iexpr, bexpr;

/* Precedences (probably useless for the current grammar) */
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left EQ, DIF;
precedence nonassoc GT, LT, LEQ, GEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left UMINUS;


/* The grammar */
expr    ::=
     PARSE_BOOL bexpr:e  {: RESULT = lexer.getExpressionClass().getBExpr(e.intValue());
                            lexer.getExpressionClass().freeBool(e.intValue()); :}
   | PARSE_INT iexpr:e   {: RESULT = lexer.getExpressionClass().getIExpr(e.intValue());
                            lexer.getExpressionClass().freeInt(e.intValue()); :}
;

iexpr   ::=
     iexpr:l PLUS iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiPlus(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
   | iexpr:l MINUS iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiMinus(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
   | iexpr:l MULT iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiMult(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
   | iexpr:l DIV iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiDiv(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
   | iexpr:l MOD iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_iiiMod(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
   | LPAR iexpr:e RPAR {: RESULT = e; :}
   | MINUS iexpr:e {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_iNeg(e.intValue())); :} %prec UMINUS
   | INT:e {: RESULT = e; :}
;

bexpr   ::=
      bexpr:l OR bexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbOr(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      :}
    | bexpr:l AND bexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbAnd(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      :}
    | BOOL:e {: RESULT = e; :}
    | LPAR bexpr:e RPAR {: RESULT = e; :}
    | NOT bexpr:e {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_bNot(e.intValue())); :}
    | iexpr:l LT iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiLt(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
    | iexpr:l GT iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiGt(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
    | iexpr:l LEQ iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiLeq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
    | iexpr:l GEQ iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiGeq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
    | iexpr:l EQ iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiEq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
    | iexpr:l DIF iexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_biiDif(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeInt(l.intValue());
         lexer.getExpressionClass().freeInt(r.intValue());
      :}
    | bexpr:l EQ bexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbEq(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      :}
    | bexpr:l DIF bexpr:r
      {: RESULT = Integer.valueOf(lexer.getExpressionClass().make_bbbDif(l.intValue(),r.intValue()));
         lexer.getExpressionClass().freeBool(l.intValue());
         lexer.getExpressionClass().freeBool(r.intValue());
      :}
;
