<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>TTool help</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="help.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="avatar-security-pragmas">AVATAR Security pragmas</h1>
<p>AVATAR security pragmas are meant to enhance AVATAR models with two
aspects: - Global security behavior - Security properties</p>
<h2 id="global-security-behavior">Global security behavior</h2>
<p>These security pragmas are meant to describe cryptographic material
that has been created and exchanged before the corresponding AVATAR
model executes.</p>
<h3 id="creating-and-sharing-symmetric-keys">Creating and sharing
symmetric keys</h3>
<p>When an AVATAR model is executed for proving security properties, the
prover assumes that this model is in fact executed an infinite number of
times. The pragma to create and share keys is meant to express whether
these keys are created and shared once for all sessions, or for each
session.</p>
<pre><code>#InitialSystemKnowledge Block1.key1 Block2.key2</code></pre>
<p>where Block1 and Block2 are blocks of the Avatar model, and key1 is
an attribute of Block1 of type Key, and key2 is an attribute of Block2
of type Key. This pragma means that key1 and key2 are created once and
are equal in all sessions, i.e., block1.key1 is always equal to
Block2.key2, and their value is the same in all sessions.</p>
<pre><code>#InitialSessionKnowledge Block1.key1 Block2.key2</code></pre>
<p>where Block1 and Block2 are blocks of the Avatar model, and key1 is
an attribute of Block1 of type Key, and key2 is an attribute of Block2
of type Key. This pragma means that key1 and key2 are different in each
session, i.e., this pragma assumes that each time a session starts, a
couple (key1, key2) is created and shared between Block1 and Block2.</p>
<h3 id="public-and-private-keys">Public and Private keys</h3>
<p>Couples of private and public keys can be defined as follows:</p>
<pre><code>#PrivatePublicKeys ABlock privKeyAttribute pubKeyAttribute</code></pre>
<p>This pragma means that Block named “ABlock” has two attributes of
type Key: privKeyAttribute and pubKeyAttribute. This pragma also states
that privKeyAttribute and pubKeyAttribute are a couple of associated
private and public keys.</p>
<h3 id="declaring-the-attacker-access-to-attributes">Declaring the
attacker access to attributes</h3>
<p>A public attribute is an attribute of a block that can be accessed by
an attacker.</p>
<pre><code>#Public  Block1.attribute1</code></pre>
<p>Similarly, an attribute can be declared as public and constant.
Contant means that its value does not change, that is the attacker knows
its value when it accesses to its value one time.</p>
<pre><code>#PublicConstant  Block1.attribute1</code></pre>
<p>Oppositely, an attribute can be set as a private constant, to enforce
the fact that the value will not be disclosed to the attacker.</p>
<pre><code>#PrivateConstant  Block1.attribute1</code></pre>
<p>Note: attributes are assumed as private (but not constant) by
default.</p>
<h2 id="security-properties">Security properties</h2>
<h3 id="confidentiality">Confidentiality</h3>
<p>The following pragma specifies that we expect the attribute
attribute1 of block Block1 to remain confidential with regards to the
attacker.</p>
<pre><code>#Confidentiality  Block1.attribute1</code></pre>
<p>Using the keyword “Secret” is equivalent to “Confidentiality”:</p>
<pre><code>#Secret  Block1.attribute1</code></pre>
<p>Also, an attribute can be assumed to be confidential. This is an
<strong>information</strong> given to the prover to simplify the proof
of other security properties.</p>
<pre><code>#SecrecyAssumption  Block1.attribute1</code></pre>
<h3 id="integrity-and-authenticity">Integrity and Authenticity</h3>
<p>In TTool, integrity is also called “Weak authenticity”, and
authenticity is called “String authenticity”. Weak authenticity refers
to the fact that a receiver receiving a message can detect that the
message was modified by an attacker. Strong authenticity assumes weak
authenticity and adds the fact that to each message received by the
receiver corresponds exactly to one message sent by the sender.</p>
<p>The following pragma states that the attribute “secretMessage” in
state “receiveMessage” of the state machine of block Server is authentic
with regards to the attribute “secretMessage” in state “sendMessage” of
the state machine of block Client.</p>
<pre><code>#Authenticity Client.sendMessage.secretMessage Server.receiveMessage.secretMessage</code></pre>
<h3 id="property-backtracing">Property backtracing</h3>
<p>Once Proverif has been invoked from TTool, proof results are
backtraced to TTool</p>
<h4 id="confidentiality-1">Confidentiality</h4>
<p>A lock is drawn next to each attribute given in a “Confidentiality”
pragma. - Green means “confidentiality satisfied” - Red means
“confidentiality not satisfied” - Grey means that the property could not
be proved</p>
<h3 id="weak-and-strong-authenticity">Weak and strong authenticity</h3>
<p>A lock is drawn next to each “Authenticity” pragma. the lock is
divided into two parts. The upper right part refers to weak
authenticity, and lower left part refers to the strong authenticity.</p>
<ul>
<li>Green means property satisfied</li>
<li>Red means property not satisfied</li>
<li>Grey means that the property could not be proved</li>
</ul>
<p>For instance, the Figure below, taken from the AliceAndBob model
illustrates an authenticity property after security proof: the lock
shows that weak authenticity is satisfied, but not strong
authenticity.</p>
<center>
<img src="file:../help/lockauthenticity_avatar.png" />
</center>
</body>
</html>
